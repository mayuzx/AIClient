[
    {
        "name": "获取系统信息",
        "example": "获取系统基本信息。示例：\nGet-SystemInfo",
        "code": "function Get-SystemInfo {\n    $info = Get-ComputerInfo | Select-Object WindowsProductName, OsVersion, OsArchitecture, TotalPhysicalMemory\n    return $info | ConvertTo-Json\n}"
    },
    {
        "name": "查看进程信息",
        "example": "查看进程信息。示例：\nGet-TopProcesses  # 获取占用内存最多的5个进程\nGet-TopProcesses -count 3  # 获取占用内存最多的3个进程\nGet-TopProcesses -name 'chrome'  # 获取指定名称的进程\nGet-TopProcesses -name 'svchost' -count 3  # 获取指定名称的前3个进程",
        "code": "function Get-TopProcesses {\n    param(\n        [string]$name = '',\n        [int]$count = 5\n    )\n    try {\n        $processes = if ($name) {\n            Get-Process -Name $name -ErrorAction Stop | Select-Object Name, WorkingSet, CPU, Id\n        } else {\n            Get-Process | Sort-Object WorkingSet -Descending | Select-Object Name, WorkingSet, CPU, Id -First $count\n        }\n        return $processes | ConvertTo-Json\n    } catch {\n        return @{\n            'Error' = $_.Exception.Message\n        } | ConvertTo-Json\n    }\n}"
    },
    {
        "name": "网络连接测试",
        "example": "测试与指定主机的网络连接。示例：\nTest-NetworkConnection -targetHost 'baidu.com'  # 测试与百度的连接\nTest-NetworkConnection -targetHost '8.8.8.8' -count 3  # 测试与谷歌DNS的连接",
        "code": "function Test-NetworkConnection {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$targetHost,\n        [int]$count = 4\n    )\n    try {\n        $result = @()\n        $pings = Test-Connection -ComputerName $targetHost -Count $count -ErrorAction Stop\n        foreach ($ping in $pings) {\n            $result += @{\n                'Target' = $ping.Address.ToString()\n                'Status' = 'Success'\n                'Time(ms)' = $ping.ResponseTime\n                'TTL' = $ping.ResponseTimeToLive\n            }\n        }\n        return $result | ConvertTo-Json\n    } catch {\n        return @{\n            'Target' = $targetHost\n            'Status' = 'Failed'\n            'Error' = $_.Exception.Message\n        } | ConvertTo-Json\n    }\n}"
    },
    {
        "name": "磁盘空间查询",
        "example": "查看所有磁盘的空间使用情况。示例：\nGet-DiskSpace",
        "code": "function Get-DiskSpace {\n    $disks = Get-WmiObject Win32_LogicalDisk | Select-Object DeviceID, @{Name='FreeSpace(GB)';Expression={[math]::Round($_.FreeSpace/1GB,2)}}, @{Name='Size(GB)';Expression={[math]::Round($_.Size/1GB,2)}}\n    return $disks | ConvertTo-Json\n}"
    },
    {
        "name": "服务状态查询",
        "example": "查询指定服务的状态。示例：\nGet-ServiceStatus -serviceName 'wuauserv'  # 查询 Windows Update 服务\nGet-ServiceStatus -serviceName 'spooler'  # 查询打印机服务",
        "code": "function Get-ServiceStatus {\n    param([string]$serviceName)\n    $service = Get-Service -Name $serviceName | Select-Object Name, Status, StartType\n    return $service | ConvertTo-Json\n}"
    },
    {
        "name": "文件搜索",
        "example": "在指定路径搜索文件。示例：\nFind-Files -path 'D:\\Documents' -filter '*.pdf'  # 搜索 PDF 文件\nFind-Files -path 'C:\\Users' -filter '*.docx'  # 搜索 Word 文档",
        "code": "function Find-Files {\n    param(\n        [string]$path = 'C:\\',\n        [string]$filter = '*.txt'\n    )\n    $files = Get-ChildItem -Path $path -Filter $filter -Recurse -ErrorAction SilentlyContinue | Select-Object FullName, Length, LastWriteTime\n    return $files | ConvertTo-Json\n}"
    },
    {
        "name": "系统事件查询",
        "example": "查询系统事件日志。示例：\nGet-SystemEvents -logName 'Application' -entryType 'Error' -count 5  # 查询最近5条应用程序错误\nGet-SystemEvents -logName 'System' -entryType 'Warning' -count 3  # 查询最近3条系统警告",
        "code": "function Get-SystemEvents {\n    param(\n        [string]$logName = 'System',\n        [string]$entryType = 'Error',\n        [int]$count = 10\n    )\n    $events = Get-EventLog -LogName $logName -EntryType $entryType -Newest $count | Select-Object TimeGenerated, Source, Message\n    return $events | ConvertTo-Json\n}"
    },
    {
        "name": "网络端口查询",
        "example": "查询网络端口状态。示例：\nGet-NetworkPorts -state 'Established'  # 查询已建立连接的端口\nGet-NetworkPorts -state 'Listen'  # 查询监听中的端口",
        "code": "function Get-NetworkPorts {\n    param([string]$state = 'Listen')\n    $ports = Get-NetTCPConnection | Where-Object State -eq $state | Select-Object LocalAddress, LocalPort, State\n    return $ports | ConvertTo-Json\n}"
    },
    {
        "name": "系统电源控制",
        "example": "控制系统关机或重启。示例：\nInvoke-PowerControl -action 'shutdown' -delay 60  # 60秒后关机\nInvoke-PowerControl -action 'restart' -delay 30  # 30秒后重启\nInvoke-PowerControl -action 'cancel'  # 取消待执行的关机或重启",
        "code": "function Invoke-PowerControl {\n    param(\n        [Parameter(Mandatory=$true)]\n        [ValidateSet('shutdown', 'restart', 'cancel')]\n        [string]$action,\n        [int]$delay = 60\n    )\n    try {\n        $result = @{}\n        switch ($action) {\n            'shutdown' {\n                $output = shutdown /s /t $delay /c \"系统将在 $delay 秒后关机\"\n                $result = @{\n                    'Action' = 'Shutdown'\n                    'Delay' = $delay\n                    'Status' = 'Scheduled'\n                    'Message' = \"系统将在 $delay 秒后关机\"\n                }\n            }\n            'restart' {\n                $output = shutdown /r /t $delay /c \"系统将在 $delay 秒后重启\"\n                $result = @{\n                    'Action' = 'Restart'\n                    'Delay' = $delay\n                    'Status' = 'Scheduled'\n                    'Message' = \"系统将在 $delay 秒后重启\"\n                }\n            }\n            'cancel' {\n                $output = shutdown /a\n                $result = @{\n                    'Action' = 'Cancel'\n                    'Status' = 'Cancelled'\n                    'Message' = '已取消待执行的关机或重启操作'\n                }\n            }\n        }\n        return $result | ConvertTo-Json\n    } catch {\n        return @{\n            'Error' = $_.Exception.Message\n        } | ConvertTo-Json\n    }\n}"
    },
    {
        "name": "端口扫描工具",
        "example": "扫描指定IP的端口。示例：\nTest-Port -ip \"192.168.1.1\" -port 80  # 扫描单个端口\nTest-Port -ip \"192.168.1.1\" -startPort 80 -endPort 100  # 扫描端口范围\nTest-Port -ip \"192.168.1.1\"  # 扫描所有常用端口",
        "code": "function Test-Port {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$ip,\n        [int]$port = 0,\n        [int]$startPort = 0,\n        [int]$endPort = 0,\n        [int]$timeout = 100\n    )\n    try {\n        $results = @()\n        \n        # 定义要扫描的端口列表\n        $portsToScan = @()\n        if ($port -gt 0) {\n            # 扫描单个端口\n            $portsToScan += $port\n        }\n        elseif ($startPort -gt 0 -and $endPort -ge $startPort) {\n            # 扫描端口范围\n            $portsToScan += $startPort..$endPort\n        }\n        else {\n            # 扫描常用端口\n            $portsToScan += @(21,22,23,25,53,80,110,135,139,143,443,445,1433,1521,3306,3389,5432,8080,8443)\n        }\n        \n        foreach ($currentPort in $portsToScan) {\n            $tcpClient = New-Object System.Net.Sockets.TcpClient\n            $connect = $tcpClient.BeginConnect($ip, $currentPort, $null, $null)\n            $wait = $connect.AsyncWaitHandle.WaitOne($timeout, $false)\n            \n            $result = @{\n                IP = $ip\n                Port = $currentPort\n                Protocol = \"TCP\"\n            }\n            \n            if ($wait) {\n                try {\n                    $tcpClient.EndConnect($connect)\n                    $result.Status = \"Open\"\n                    \n                    # 尝试获取服务名称\n                    try {\n                        $service = [System.Net.NetworkInformation.IPGlobalProperties]::GetIPGlobalProperties().GetActiveConnections() |\n                            Where-Object { $_.LocalEndPoint.Port -eq $currentPort } |\n                            Select-Object -First 1\n                        if ($service) {\n                            $result.Service = $service.State.ToString()\n                        }\n                    } catch {}\n                    \n                } catch {\n                    $result.Status = \"Filtered\"\n                }\n            } else {\n                $result.Status = \"Closed\"\n            }\n            \n            $results += $result\n            $tcpClient.Close()\n        }\n        \n        return $results | ConvertTo-Json\n    } catch {\n        return @{\n            Error = $_.Exception.Message\n            IP = $ip\n            Port = if ($port -gt 0) { $port } else { \"$startPort-$endPort\" }\n        } | ConvertTo-Json\n    }\n}"
    },
    {
        "name": "内存查看工具",
        "example": "查看系统内存使用情况。示例：\nGet-MemoryStatus  # 查看总体内存状态\nGet-MemoryStatus -detail  # 查看详细内存信息\nGet-MemoryStatus -process \"chrome\"  # 查看指定进程的内存使用",
        "code": "function Get-MemoryStatus {\n    param(\n        [switch]$detail,\n        [string]$process = ''\n    )\n    try {\n        if ($process) {\n            # 查看指定进程的内存使用\n            $processInfo = Get-Process -Name $process | Select-Object Name, @{Name='WorkingSet(MB)';Expression={[math]::Round($_.WorkingSet/1MB, 2)}}, @{Name='PrivateMemory(MB)';Expression={[math]::Round($_.PrivateMemorySize/1MB, 2)}}, @{Name='VirtualMemory(MB)';Expression={[math]::Round($_.VirtualMemorySize/1MB, 2)}}\n            return $processInfo | ConvertTo-Json\n        }\n        \n        # 获取系统内存信息\n        $os = Get-WmiObject Win32_OperatingSystem\n        $memoryInfo = @{\n            TotalPhysicalMemory = [math]::Round($os.TotalVisibleMemorySize/1MB, 2)\n            FreePhysicalMemory = [math]::Round($os.FreePhysicalMemory/1KB, 2)\n            UsedPhysicalMemory = [math]::Round(($os.TotalVisibleMemorySize - $os.FreePhysicalMemory)/1KB, 2)\n            MemoryUsagePercent = [math]::Round(($os.TotalVisibleMemorySize - $os.FreePhysicalMemory) * 100 / $os.TotalVisibleMemorySize, 2)\n        }\n        \n        if ($detail) {\n            # 添加详细信息\n            $computerSystem = Get-WmiObject Win32_ComputerSystem\n            $pageFile = Get-WmiObject Win32_PageFileUsage\n            \n            $memoryInfo.Add('TotalVirtualMemory', [math]::Round(($os.TotalVirtualMemorySize)/1MB, 2))\n            $memoryInfo.Add('FreeVirtualMemory', [math]::Round(($os.FreeVirtualMemory)/1KB, 2))\n            $memoryInfo.Add('PageFileSize', [math]::Round($pageFile.AllocatedBaseSize, 2))\n            $memoryInfo.Add('PageFileUsage', [math]::Round($pageFile.CurrentUsage, 2))\n            $memoryInfo.Add('SystemCache', [math]::Round(($os.SizeStoredInPagingFiles)/1MB, 2))\n            \n            # 获取前5个内存占用最多的进程\n            $topProcesses = Get-Process | Sort-Object WorkingSet -Descending | Select-Object -First 5 | Select-Object Name, @{Name='Memory(MB)';Expression={[math]::Round($_.WorkingSet/1MB, 2)}}\n            $memoryInfo.Add('TopProcesses', $topProcesses)\n        }\n        \n        return $memoryInfo | ConvertTo-Json -Depth 10\n    } catch {\n        return @{\n            Error = $_.Exception.Message\n        } | ConvertTo-Json\n    }\n}"
    },
    {
        "name": "内存清理工具",
        "example": "清理系统内存。示例：\nClear-Memory  # 执行基本内存清理\nClear-Memory -aggressive  # 执行深度内存清理",
        "code": "function Clear-Memory {\n    param([switch]$aggressive)\n    try {\n        $result = @{\n            Status = \"Success\"\n            Actions = @()\n            MemoryBefore = 0\n            MemoryAfter = 0\n        }\n        \n        # 获取初始内存状态\n        $os = Get-WmiObject Win32_OperatingSystem\n        $result.MemoryBefore = [math]::Round($os.FreePhysicalMemory/1KB, 2)\n        $result.Actions += \"Starting memory cleanup...\"\n        \n        # 基础清理\n        [System.GC]::Collect()\n        [System.GC]::WaitForPendingFinalizers()\n        $result.Actions += \"Performed garbage collection\"\n        \n        # 清理进程工作集\n        Get-Process | ForEach-Object {\n            try {\n                [void][System.Runtime.InteropServices.Marshal]::SetProcessWorkingSetSize($_.Handle, -1, -1)\n            } catch {}\n        }\n        $result.Actions += \"Cleaned processes working set\"\n        \n        # 清理系统缓存\n        $clearCache = @'\n        [DllImport(\"psapi.dll\")]\n        public static extern int EmptyWorkingSet(IntPtr hwProc);\n'@\n        $psapi = Add-Type -MemberDefinition $clearCache -Name PSAPILib -Namespace PSAPILib -PassThru\n        Get-Process | ForEach-Object {\n            try { $psapi::EmptyWorkingSet($_.Handle) } catch {}\n        }\n        $result.Actions += \"Cleaned system cache\"\n        \n        if ($aggressive) {\n            $result.Actions += \"Starting deep cleanup...\"\n            \n            # 清理文件系统缓存\n            Write-OutputDebugString -Message \"GlobalMemoryStatus\"\n            $result.Actions += \"Cleaned filesystem cache\"\n            \n            # 清理系统待机列表\n            $clearStandbyList = @'\n            [DllImport(\"psapi.dll\")]\n            public static extern int EmptyWorkingSet(IntPtr hwProc);\n            [DllImport(\"ntdll.dll\")]\n            public static extern uint NtSetSystemInformation(int InfoClass, IntPtr Info, int Length);\n'@\n            $ntdll = Add-Type -MemberDefinition $clearStandbyList -Name NtDllLib -Namespace NtDllLib -PassThru\n            try { $ntdll::NtSetSystemInformation(80, [IntPtr]::Zero, 0) } catch {}\n            $result.Actions += \"Cleaned standby list\"\n            \n            # 清理DNS缓存\n            ipconfig /flushdns | Out-Null\n            $result.Actions += \"Cleaned DNS cache\"\n            \n            # 清理回收站\n            Clear-RecycleBin -Force -ErrorAction SilentlyContinue\n            $result.Actions += \"Cleaned recycle bin\"\n        }\n        \n        # 获取最终内存状态\n        Start-Sleep -Seconds 2\n        $os = Get-WmiObject Win32_OperatingSystem\n        $result.MemoryAfter = [math]::Round($os.FreePhysicalMemory/1KB, 2)\n        $result.MemoryFreed = [math]::Round($result.MemoryAfter - $result.MemoryBefore, 2)\n        \n        return $result | ConvertTo-Json\n    } catch {\n        return @{\n            Status = \"Failed\"\n            Error = $_.Exception.Message\n        } | ConvertTo-Json\n    }\n}"
    },
    {
        "name": "回收站管理工具",
        "example": "管理系统回收站。示例：\nClear-RecycleBin  # 清空所有回收站\nClear-RecycleBin -drive \"C:\"  # 清空指定盘符的回收站\nGet-RecycleBinSize  # 获取回收站大小",
        "code": "function Clear-RecycleBin {\n    param(\n        [string]$drive = ''\n    )\n    try {\n        $result = @{\n            Status = \"Success\"\n            Actions = @()\n            SizeBefore = 0\n            SizeAfter = 0\n        }\n        \n        # 获取清理前的大小\n        $shell = New-Object -ComObject Shell.Application\n        $recycleBin = $shell.Namespace(0xa)\n        $result.SizeBefore = ($recycleBin.Items() | Measure-Object Size -Sum).Sum / 1MB\n        \n        # 执行清理\n        if ($drive) {\n            # 清理指定盘符的回收站\n            if (Test-Path $drive) {\n                $driveLetter = $drive.Substring(0,1)\n                Start-Process \"cmd.exe\" -ArgumentList \"/c rd /s /q $($driveLetter):\\`$Recycle.bin\" -WindowStyle Hidden -Wait\n                $result.Actions += \"Cleaned recycle bin for drive $drive\"\n            } else {\n                throw \"Drive $drive not found\"\n            }\n        } else {\n            # 清理所有回收站\n            $drives = Get-PSDrive -PSProvider FileSystem | Where-Object { $_.Free -gt 0 }\n            foreach ($d in $drives) {\n                Start-Process \"cmd.exe\" -ArgumentList \"/c rd /s /q $($d.Root)\\`$Recycle.bin\" -WindowStyle Hidden -Wait\n            }\n            $result.Actions += \"Cleaned all recycle bins\"\n        }\n        \n        # 获取清理后的大小\n        Start-Sleep -Seconds 1  # 等待清理完成\n        $result.SizeAfter = ($recycleBin.Items() | Measure-Object Size -Sum).Sum / 1MB\n        $result.FreedSpace = [math]::Round($result.SizeBefore - $result.SizeAfter, 2)\n        \n        return $result | ConvertTo-Json\n    } catch {\n        return @{\n            Status = \"Failed\"\n            Error = $_.Exception.Message\n        } | ConvertTo-Json\n    }\n}\n\nfunction Get-RecycleBinSize {\n    try {\n        $shell = New-Object -ComObject Shell.Application\n        $recycleBin = $shell.Namespace(0xa)\n        $items = $recycleBin.Items()\n        \n        $result = @{\n            TotalSize = [math]::Round(($items | Measure-Object Size -Sum).Sum / 1MB, 2)\n            ItemCount = ($items | Measure-Object).Count\n            Details = @()\n        }\n        \n        # 获取每个项目的详细信息\n        foreach ($item in $items) {\n            $result.Details += @{\n                Name = $item.Name\n                Size = [math]::Round($item.Size / 1MB, 2)\n                DateDeleted = $item.ModifyDate\n            }\n        }\n        \n        return $result | ConvertTo-Json -Depth 3\n    } catch {\n        return @{\n            Status = \"Failed\"\n            Error = $_.Exception.Message\n        } | ConvertTo-Json\n    }\n}"
    },
    {
        "name": "回收站大小查看工具",
        "example": "查看回收站大小。示例：\nGet-RecycleBinSize  # 获取回收站大小和内容",
        "code": "function Get-RecycleBinSize {\n    try {\n        $shell = New-Object -ComObject Shell.Application\n        $recycleBin = $shell.Namespace(0xa)\n        $items = $recycleBin.Items()\n        \n        $result = @{\n            TotalSize = [math]::Round(($items | Measure-Object Size -Sum).Sum / 1MB, 2)\n            ItemCount = ($items | Measure-Object).Count\n            Details = @()\n        }\n        \n        # 获取每个项目的详细信息\n        foreach ($item in $items) {\n            $result.Details += @{\n                Name = $item.Name\n                Size = [math]::Round($item.Size / 1MB, 2)\n                DateDeleted = $item.ModifyDate\n            }\n        }\n        \n        return $result | ConvertTo-Json -Depth 3\n    } catch {\n        return @{\n            Status = \"Failed\"\n            Error = $_.Exception.Message\n        } | ConvertTo-Json\n    }\n}"
    },
    {
        "name": "文件占用查看工具",
        "example": "查看文件被哪些进程占用。示例：\nGet-FileLocks -path \"C:\\test.txt\"  # 查看指定文件的占用情况",
        "code": "function Get-FileLocks {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$path\n    )\n    try {\n        $result = @{\n            Path = $path\n            Processes = @()\n        }\n        \n        # 检查路径是否存在\n        if (-not (Test-Path $path)) {\n            throw \"Path not found: $path\"\n        }\n        \n        # 使用 WMI 查询查找占用进程\n        $query = \"SELECT * FROM Win32_Process\"\n        $processes = Get-WmiObject -Query $query\n        \n        foreach ($proc in $processes) {\n            try {\n                if ($proc.ExecutablePath -and (Test-Path $proc.ExecutablePath)) {\n                    $process = Get-Process -Id $proc.ProcessId -ErrorAction SilentlyContinue\n                    if ($process) {\n                        $handles = $process.Modules | Where-Object { $_.FileName -eq $path }\n                        if ($handles -or $process.Path -eq $path) {\n                            $result.Processes += @{\n                                Name = $proc.Name\n                                PID = $proc.ProcessId\n                                Path = $proc.ExecutablePath\n                            }\n                        }\n                    }\n                }\n            } catch {}\n        }\n        \n        return $result | ConvertTo-Json -Depth 3\n    } catch {\n        return @{\n            Error = $_.Exception.Message\n            Path = $path\n        } | ConvertTo-Json\n    }\n}"
    },
    {
        "name": "文件解锁工具",
        "example": "解锁被占用的文件。示例：\nUnlock-File -path \"C:\\test.txt\"  # 解锁单个文件\nUnlock-File -path \"D:\\folder\"  # 解锁文件夹下所有文件",
        "code": "function Unlock-File {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$path\n    )\n    try {\n        $result = @{\n            Status = \"Success\"\n            Path = $path\n            Actions = @()\n            UnlockedFiles = @()\n        }\n        \n        # 检查路径是否存在\n        if (-not (Test-Path $path)) {\n            throw \"Path not found: $path\"\n        }\n        \n        # 获取要处理的文件列表\n        $files = if (Test-Path -Path $path -PathType Container) {\n            Get-ChildItem -Path $path -Recurse -File\n        } else {\n            Get-Item -Path $path\n        }\n        \n        foreach ($file in $files) {\n            # 获取占用文件的进程\n            $query = \"SELECT * FROM Win32_Process WHERE ExecutablePath LIKE '%$($file.Name)%'\"\n            $processes = Get-WmiObject -Query $query\n            \n            if ($processes) {\n                foreach ($process in $processes) {\n                    try {\n                        Stop-Process -Id $process.ProcessId -Force -ErrorAction SilentlyContinue\n                        $result.Actions += \"Stopped process $($process.Name) (PID: $($process.ProcessId))\"\n                        $result.UnlockedFiles += $file.FullName\n                    } catch {}\n                }\n            }\n        }\n        \n        if ($result.UnlockedFiles.Count -eq 0) {\n            $result.Status = \"NoLocks\"\n            $result.Actions += \"No locks found for the specified path\"\n        }\n        \n        return $result | ConvertTo-Json\n    } catch {\n        return @{\n            Status = \"Failed\"\n            Error = $_.Exception.Message\n            Path = $path\n        } | ConvertTo-Json\n    }\n}"
    },
    {
        "name": "进程管理工具",
        "example": "管理系统进程。示例：\nStop-ProcessByName -name \"notepad\"  # 关闭指定名称的进程\nStop-ProcessByName -name \"chrome\" -force  # 强制关闭进程\nStart-ProcessByPath -path \"C:\\Windows\\notepad.exe\"  # 启动指定程序\nStart-ProcessByPath -path \"C:\\Program Files\\Internet Explorer\\iexplore.exe\" -args \"-private\"  # 带参数启动程序",
        "code": "function Stop-ProcessByName {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$name,\n        [switch]$force\n    )\n    try {\n        $result = @{\n            Status = \"Success\"\n            ProcessName = $name\n            Actions = @()\n            StoppedProcesses = @()\n        }\n        \n        # 获取指定名称的进程\n        $processes = Get-Process -Name $name -ErrorAction Stop\n        \n        foreach ($proc in $processes) {\n            try {\n                if ($force) {\n                    $proc | Stop-Process -Force -ErrorAction Stop\n                    $result.Actions += \"Force stopped process $($proc.Name) (PID: $($proc.Id))\"\n                } else {\n                    $proc | Stop-Process -ErrorAction Stop\n                    $result.Actions += \"Stopped process $($proc.Name) (PID: $($proc.Id))\"\n                }\n                $result.StoppedProcesses += @{\n                    Name = $proc.Name\n                    PID = $proc.Id\n                    Path = $proc.Path\n                }\n            } catch {\n                $result.Actions += \"Failed to stop process $($proc.Name) (PID: $($proc.Id)): $($_.Exception.Message)\"\n            }\n        }\n        \n        return $result | ConvertTo-Json -Depth 3\n    } catch {\n        return @{\n            Status = \"Failed\"\n            Error = $_.Exception.Message\n            ProcessName = $name\n        } | ConvertTo-Json\n    }\n}\n\nfunction Start-ProcessByPath {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$path,\n        [string]$args = \"\"\n    )\n    try {\n        $result = @{\n            Status = \"Success\"\n            Path = $path\n            Arguments = $args\n            Process = $null\n        }\n        \n        # 检查文件是否存在\n        if (-not (Test-Path $path)) {\n            throw \"File not found: $path\"\n        }\n        \n        # 启动进程\n        $processInfo = New-Object System.Diagnostics.ProcessStartInfo\n        $processInfo.FileName = $path\n        if ($args) {\n            $processInfo.Arguments = $args\n        }\n        $processInfo.UseShellExecute = $true\n        \n        $process = [System.Diagnostics.Process]::Start($processInfo)\n        \n        $result.Process = @{\n            Name = $process.ProcessName\n            PID = $process.Id\n            Path = $path\n            StartTime = $process.StartTime\n        }\n        \n        return $result | ConvertTo-Json\n    } catch {\n        return @{\n            Status = \"Failed\"\n            Error = $_.Exception.Message\n            Path = $path\n        } | ConvertTo-Json\n    }\n}"
    },
    {
        "name": "CPU信息查看工具",
        "example": "查看CPU详细信息。示例：\nGet-CPUInfo  # 查看CPU基本信息\nGet-CPUInfo -detail  # 查看CPU详细信息",
        "code": "function Get-CPUInfo {\n    param([switch]$detail)\n    try {\n        $result = @{\n            Status = \"Success\"\n            Basic = $null\n            Detail = $null\n        }\n        \n        # 获取基本CPU信息\n        $cpu = Get-WmiObject -Class Win32_Processor\n        $result.Basic = @{\n            Name = $cpu.Name\n            Manufacturer = $cpu.Manufacturer\n            Description = $cpu.Description\n            Cores = $cpu.NumberOfCores\n            LogicalProcessors = $cpu.NumberOfLogicalProcessors\n            CurrentClockSpeed = $cpu.CurrentClockSpeed\n            MaxClockSpeed = $cpu.MaxClockSpeed\n            Status = $cpu.Status\n        }\n        \n        if ($detail) {\n            # 获取详细信息\n            $result.Detail = @{\n                Architecture = $cpu.Architecture\n                AddressWidth = $cpu.AddressWidth\n                DataWidth = $cpu.DataWidth\n                L2CacheSize = $cpu.L2CacheSize\n                L3CacheSize = $cpu.L3CacheSize\n                SocketDesignation = $cpu.SocketDesignation\n                ProcessorId = $cpu.ProcessorId\n                DeviceID = $cpu.DeviceID\n                Caption = $cpu.Caption\n                CurrentVoltage = $cpu.CurrentVoltage\n                Version = $cpu.Version\n                LoadPercentage = $cpu.LoadPercentage\n                PowerManagementSupported = $cpu.PowerManagementSupported\n                VirtualizationFirmwareEnabled = $cpu.VirtualizationFirmwareEnabled\n            }\n        }\n        \n        return $result | ConvertTo-Json -Depth 5\n    } catch {\n        return @{\n            Status = \"Failed\"\n            Error = $_.Exception.Message\n        } | ConvertTo-Json\n    }\n}"
    },
    {
        "name": "GPU信息查看工具",
        "example": "查看GPU详细信息。示例：\nGet-GPUInfo  # 查看显卡信息",
        "code": "function Get-GPUInfo { try { $result = @{ Status = \"Success\"; GPUs = @() }; $gpus = Get-WmiObject Win32_VideoController; foreach ($gpu in $gpus) { $gpuInfo = @{ Name = $gpu.Caption; RAM = if ($gpu.AdapterRAM) { [math]::Round($gpu.AdapterRAM/1GB, 2) } else { 0 }; Resolution = if ($gpu.CurrentHorizontalResolution -and $gpu.CurrentVerticalResolution) { \"$($gpu.CurrentHorizontalResolution)x$($gpu.CurrentVerticalResolution)\" } else { \"Unknown\" }; BitsPerPixel = $gpu.CurrentBitsPerPixel; RefreshRate = $gpu.CurrentRefreshRate; DriverVersion = $gpu.DriverVersion; Status = $gpu.Status; VideoProcessor = $gpu.VideoProcessor; VideoMemoryType = $gpu.VideoMemoryType; VideoArchitecture = $gpu.VideoArchitecture }; $result.GPUs += $gpuInfo }; return $result | ConvertTo-Json -Depth 3 } catch { return @{ Status = \"Failed\"; Error = $_.Exception.Message } | ConvertTo-Json } }"
    },
    {
        "name": "CSV转TXT工具",
        "example": "将CSV文件转换为TXT文件。示例：\nConvert-CSV2TXT -path \"D:\\data.csv\"  # 转换指定的CSV文件\nConvert-CSV2TXT -path \"D:\\data.csv\" -delimiter \",\"  # 指定分隔符",
        "code": "function Convert-CSV2TXT { param([Parameter(Mandatory=$true)][string]$path, [string]$delimiter = \",\") try { $result = @{ Status = \"Success\"; Path = $path; Lines = @() }; if (-not (Test-Path $path)) { throw \"File not found: $path\" }; $table = Import-CSV -Path $path -Delimiter $delimiter; foreach($row in $table) { $line = \"* \"; $row.PSObject.Properties | ForEach-Object { $line += \"$($_.Value) \" }; $result.Lines += $line.TrimEnd() }; return $result | ConvertTo-Json } catch { return @{ Status = \"Failed\"; Error = $_.Exception.Message; Path = $path } | ConvertTo-Json } }"
    },
    {
        "name": "目录压缩工具",
        "example": "将目录压缩为ZIP文件。示例：\nConvert-Dir2Zip -path \"D:\\Documents\"  # 压缩指定目录\nConvert-Dir2Zip -path \"D:\\Documents\" -zipFile \"D:\\backup.zip\"  # 指定输出文件名",
        "code": "function Convert-Dir2Zip { param([Parameter(Mandatory=$true)][string]$path, [string]$zipFile = \"\") try { $result = @{ Status = \"Success\"; Path = $path; ZipFile = $null; Size = 0 }; if (-not (Test-Path $path -PathType Container)) { throw \"Directory not found: $path\" }; if (-not $zipFile) { $zipFile = \"$path.zip\" }; Add-Type -AssemblyName System.IO.Compression.FileSystem; [System.IO.Compression.ZipFile]::CreateFromDirectory($path, $zipFile, [System.IO.Compression.CompressionLevel]::Optimal, $false); $result.ZipFile = $zipFile; $result.Size = [math]::Round((Get-Item $zipFile).Length/1MB, 2); return $result | ConvertTo-Json } catch { return @{ Status = \"Failed\"; Error = $_.Exception.Message; Path = $path } | ConvertTo-Json } }"
    },
    {
        "name": "Word转Markdown工具",
        "example": "将Word文档转换为Markdown格式。示例：\nConvert-DOCX2MD -path \"D:\\document.docx\"  # 转换单个Word文档\nConvert-DOCX2MD -path \"D:\\Documents\" -recursive  # 递归转换目录下所有Word文档",
        "code": "function Convert-DOCX2MD { param([Parameter(Mandatory=$true)][string]$path, [switch]$recursive) try { $result = @{ Status = \"Success\"; Files = @() }; if (-not (Test-Path $path)) { throw \"Path not found: $path\" }; $word = New-Object -ComObject Word.Application; $word.Visible = $false; $files = if ((Get-Item $path).PSIsContainer -and $recursive) { Get-ChildItem -Path $path -Filter *.docx -Recurse } elseif ((Get-Item $path).PSIsContainer) { Get-ChildItem -Path $path -Filter *.docx } else { Get-Item $path }; foreach ($file in $files) { try { $doc = $word.Documents.Open($file.FullName); $mdPath = $file.FullName -replace '\\.docx$', '.md'; $doc.SaveAs([ref]$mdPath, [ref]19); $doc.Close(); $result.Files += @{ Source = $file.FullName; Target = $mdPath; Status = \"Success\" } } catch { $result.Files += @{ Source = $file.FullName; Error = $_.Exception.Message; Status = \"Failed\" } } }; $word.Quit(); [System.Runtime.Interopservices.Marshal]::ReleaseComObject($word) | Out-Null; return $result | ConvertTo-Json -Depth 3 } catch { return @{ Status = \"Failed\"; Error = $_.Exception.Message; Path = $path } | ConvertTo-Json } }"
    },
    {
        "name": "二维码生成工具",
        "example": "生成二维码图片。示例：\nNew-QRCode -text \"Hello World\" -size \"500x500\" -format \"PNG\"  # 生成指定内容的二维码\nNew-QRCode -text \"https://github.com\" -size \"300x300\"  # 生成网址二维码",
        "code": "function New-QRCode {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$text,\n        [string]$size = \"500x500\",\n        [string]$format = \"PNG\"\n    )\n    try {\n        # 添加 System.Web 引用\n        Add-Type -AssemblyName System.Web\n        \n        $result = @{\n            Status = \"Success\"\n            Text = $text\n            ImagePath = $null\n        }\n        \n        $ecc = \"M\"\n        $quietZone = 1\n        $fgColor = \"000000\"\n        $bgColor = \"ffffff\"\n        \n        # 获取图片保存路径\n        $picPath = [Environment]::GetFolderPath('MyPictures')\n        if (-not (Test-Path $picPath -PathType Container)) {\n            throw \"Pictures folder not found: $picPath\"\n        }\n        \n        # 生成文件名\n        $fileName = \"QR_$(Get-Date -Format 'yyyyMMddHHmmss').$format\"\n        $filePath = Join-Path $picPath $fileName\n        \n        # 下载二维码\n        $webClient = New-Object System.Net.WebClient\n        $url = \"http://api.qrserver.com/v1/create-qr-code/?data=$([System.Web.HttpUtility]::UrlEncode($text))&ecc=$ecc&size=$size&qzone=$quietZone&color=$fgColor&bgcolor=$bgColor&format=$format\"\n        $webClient.DownloadFile($url, $filePath)\n        \n        $result.ImagePath = $filePath\n        \n        # 打开文件位置\n        if (Test-Path $filePath) {\n            Start-Process \"explorer.exe\" -ArgumentList \"/select,`\"$filePath`\"\"\n        }\n        \n        return $result | ConvertTo-Json\n    } catch {\n        return @{\n            Status = \"Failed\"\n            Error = $_.Exception.Message\n        } | ConvertTo-Json\n    }\n}"
    },
    {
        "name": "Hosts文件编辑工具",
        "example": "打开和编辑系统Hosts文件。示例：\nEdit-HostsFile  # 打开Hosts文件\nEdit-HostsFile -backup  # 打开Hosts文件并创建备份",
        "code": "function Edit-HostsFile {\n    param([switch]$backup)\n    try {\n        $result = @{\n            Status = \"Success\"\n            HostsPath = $null\n            BackupPath = $null\n        }\n        \n        $hostsPath = \"$env:windir\\System32\\drivers\\etc\\hosts\"\n        if (-not (Test-Path $hostsPath)) {\n            throw \"Hosts file not found\"\n        }\n        \n        if ($backup) {\n            $backupPath = \"$hostsPath.bak_$(Get-Date -Format 'yyyyMMddHHmmss')\"\n            Copy-Item -Path $hostsPath -Destination $backupPath -Force\n            $result.BackupPath = $backupPath\n        }\n        \n        $result.HostsPath = $hostsPath\n        \n        # 检查是否有管理员权限\n        $identity = [Security.Principal.WindowsIdentity]::GetCurrent()\n        $principal = New-Object Security.Principal.WindowsPrincipal($identity)\n        $isAdmin = $principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)\n        \n        if (-not $isAdmin) {\n            Start-Process \"notepad.exe\" -ArgumentList $hostsPath -Verb RunAs\n        } else {\n            Start-Process \"notepad.exe\" -ArgumentList $hostsPath\n        }\n        \n        return $result | ConvertTo-Json\n    } catch {\n        return @{\n            Status = \"Failed\"\n            Error = $_.Exception.Message\n        } | ConvertTo-Json\n    }\n}"
    },
    {
        "name": "环境变量配置工具",
        "example": "打开和管理系统环境变量。示例：\nEdit-EnvironmentVariables  # 打开环境变量配置\nEdit-EnvironmentVariables -list  # 列出所有环境变量\nEdit-EnvironmentVariables -add \"MY_VAR\" \"MY_VALUE\"  # 添加环境变量\nEdit-EnvironmentVariables -remove \"MY_VAR\"  # 删除环境变量",
        "code": "function Edit-EnvironmentVariables { param([switch]$list, [string]$add = \"\", [string]$value = \"\", [string]$remove = \"\") try { $result = @{ Status = \"Success\"; Action = \"None\"; Variables = @{} }; $identity = [Security.Principal.WindowsIdentity]::GetCurrent(); $principal = New-Object Security.Principal.WindowsPrincipal($identity); $isAdmin = $principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator); if ($list) { $result.Action = \"List\"; $result.Variables = @{ System = @{}; User = @{} }; [System.Environment]::GetEnvironmentVariables('Machine').GetEnumerator() | ForEach-Object { $result.Variables.System[$_.Key] = $_.Value }; [System.Environment]::GetEnvironmentVariables('User').GetEnumerator() | ForEach-Object { $result.Variables.User[$_.Key] = $_.Value } } elseif ($add -and $value) { if (-not $isAdmin) { throw \"Requires administrator privileges\" }; $result.Action = \"Add\"; [System.Environment]::SetEnvironmentVariable($add, $value, 'Machine'); $result.Variables[$add] = $value } elseif ($remove) { if (-not $isAdmin) { throw \"Requires administrator privileges\" }; $result.Action = \"Remove\"; [System.Environment]::SetEnvironmentVariable($remove, $null, 'Machine'); $result.Variables[$remove] = \"Removed\" } else { $result.Action = \"OpenDialog\"; Start-Process \"rundll32.exe\" -ArgumentList \"sysdm.cpl,EditEnvironmentVariables\" -Verb RunAs }; return $result | ConvertTo-Json -Depth 3 } catch { return @{ Status = \"Failed\"; Error = $_.Exception.Message } | ConvertTo-Json } }"
    },
    {
        "name": "文件读取工具",
        "example": "读取文件内容。示例：\nRead-FileContent -path \"C:\\test.txt\"  # 读取文本文件\nRead-FileContent -path \"C:\\test.txt\" -tail 10  # 读取文件最后10行\nRead-FileContent -path \"C:\\test.txt\" -encoding \"utf8\"  # 指定编码读取文件",
        "code": "function Read-FileContent { param([Parameter(Mandatory=$true)][string]$path, [int]$tail = 0, [string]$encoding = \"utf8\") try { if (-not (Test-Path $path)) { throw \"File not found: $path\" }; if ((Get-Item $path).PSIsContainer) { throw \"Path is a directory\" }; $content = if ($tail -gt 0) { Get-Content -Path $path -Tail $tail -Raw -Encoding $encoding } else { Get-Content -Path $path -Raw -Encoding $encoding }; return $content } catch { return \"Error: $($_.Exception.Message)\" } }"
    },
    {
        "name": "文件程序启动工具",
        "example": "打开文件或启动程序。示例：\nOpen-FileOrProgram -path \"C:\\test.txt\"  # 打开文件\nOpen-FileOrProgram -path \"C:\\Windows\\notepad.exe\"  # 启动程序\nOpen-FileOrProgram -path \"C:\\Program Files\\Google Chrome\\chrome.exe\" -args \"--incognito\"  # 带参数启动程序\nOpen-FileOrProgram -path \"https://www.google.com\"  # 打开网址\nOpen-FileOrProgram -path \"%windir%\"  # 打开系统文件夹",
        "code": "function Open-FileOrProgram {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$path,\n        [string]$args = \"\"\n    )\n    try {\n        $result = @{\n            Status = \"Success\"\n            Action = \"None\"\n            Path = $path\n        }\n        \n        # 展开环境变量\n        $expandedPath = [System.Environment]::ExpandEnvironmentVariables($path)\n        \n        # 检查是否是URL\n        if ($path -match '^https?://') {\n            Start-Process $path\n            $result.Action = \"OpenURL\"\n        } else {\n            # 检查路径是否存在\n            if (Test-Path $expandedPath) {\n                if ($args) {\n                    Start-Process $expandedPath -ArgumentList $args\n                    $result.Action = \"StartWithArgs\"\n                } else {\n                    Start-Process $expandedPath\n                    $result.Action = \"Start\"\n                }\n            } else {\n                throw \"Path not found: $expandedPath\"\n            }\n        }\n        \n        return $result | ConvertTo-Json\n    } catch {\n        return @{\n            Status = \"Failed\"\n            Error = $_.Exception.Message\n            Path = $path\n        } | ConvertTo-Json\n    }\n}"
    },
    {
        "name": "程序安装路径查询工具",
        "example": "查询已安装程序的路径。示例：\nGet-ProgramPath -name \"Chrome\"  # 查询Chrome的安装路径\nGet-ProgramPath -name \"Visual Studio\"  # 查询VS的安装路径\nGet-ProgramPath -list  # 列出所有已安装程序",
        "code": "function Get-ProgramPath {\n    param(\n        [string]$name = \"\",\n        [switch]$list\n    )\n    try {\n        $result = @{\n            Status = \"Success\"\n            Programs = @()\n        }\n        \n        # 获取注册表中的程序信息\n        $uninstallKeys = @(\n            \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\",\n            \"HKLM:\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\"\n        )\n        \n        $programs = foreach ($key in $uninstallKeys) {\n            Get-ItemProperty $key -ErrorAction SilentlyContinue | \n            Where-Object { $_.DisplayName -and $_.InstallLocation } | \n            Select-Object DisplayName, InstallLocation, DisplayVersion, Publisher\n        }\n        \n        if ($name) {\n            # 搜索指定程序\n            $programs = $programs | Where-Object { \n                $_.DisplayName -match $name -or \n                $_.DisplayName -like \"*$name*\"\n            }\n        }\n        \n        foreach ($prog in $programs) {\n            if (Test-Path $prog.InstallLocation) {\n                $result.Programs += @{\n                    Name = $prog.DisplayName\n                    Path = $prog.InstallLocation\n                    Version = $prog.DisplayVersion\n                    Publisher = $prog.Publisher\n                }\n            }\n        }\n        \n        # 如果没有找到程序，尝试在常见安装路径中搜索\n        if ($name -and $result.Programs.Count -eq 0) {\n            $commonPaths = @(\n                \"${env:ProgramFiles}\",\n                \"${env:ProgramFiles(x86)}\",\n                \"${env:LocalAppData}\\Programs\",\n                \"${env:AppData}\\Local\\Programs\"\n            )\n            \n            foreach ($basePath in $commonPaths) {\n                if (Test-Path $basePath) {\n                    Get-ChildItem $basePath -Recurse -ErrorAction SilentlyContinue | \n                    Where-Object { \n                        $_.PSIsContainer -and \n                        ($_.Name -match $name -or $_.Name -like \"*$name*\")\n                    } | ForEach-Object {\n                        $result.Programs += @{\n                            Name = $_.Name\n                            Path = $_.FullName\n                            Version = \"Unknown\"\n                            Publisher = \"Unknown\"\n                        }\n                    }\n                }\n            }\n        }\n        \n        if (-not $list -and $result.Programs.Count -eq 0) {\n            throw \"No programs found matching: $name\"\n        }\n        \n        return $result | ConvertTo-Json -Depth 3\n    } catch {\n        return @{\n            Status = \"Failed\"\n            Error = $_.Exception.Message\n            SearchTerm = $name\n        } | ConvertTo-Json\n    }\n}"
    },
    {
        "name": "系统垃圾清理工具",
        "example": "清理系统垃圾文件。示例：\nClear-SystemJunk  # 执行基本清理\nClear-SystemJunk -aggressive  # 执行深度清理\nClear-SystemJunk -customPath \"D:\\Temp\"  # 清理指定目录",
        "code": "function Clear-SystemJunk {\n    param(\n        [switch]$aggressive,\n        [string]$customPath = \"\"\n    )\n    try {\n        $result = @{\n            Status = \"Success\"\n            Actions = @()\n            SpaceFreed = 0\n            Details = @{}\n        }\n        \n        # 获取清理前的空间使用情况\n        $beforeSize = @{}\n        Get-WmiObject Win32_LogicalDisk | Where-Object { $_.DriveType -eq 3 } | ForEach-Object {\n            $beforeSize[$_.DeviceID] = $_.FreeSpace\n        }\n        \n        # 基础清理路径\n        $paths = @{\n            'Temp' = \"$env:TEMP\"\n            'Windows Temp' = \"$env:windir\\Temp\"\n            'Prefetch' = \"$env:windir\\Prefetch\"\n            'Recent' = [Environment]::GetFolderPath('Recent')\n        }\n        \n        # 添加自定义路径\n        if ($customPath -and (Test-Path $customPath)) {\n            $paths['Custom'] = $customPath\n        }\n        \n        # 如果是深度清理，添加更多路径\n        if ($aggressive) {\n            $paths['SoftwareDistribution'] = \"$env:windir\\SoftwareDistribution\\Download\"\n            $paths['Windows Update Logs'] = \"$env:windir\\WindowsUpdate*.log\"\n            $paths['Windows Logs'] = \"$env:windir\\Logs\"\n            $paths['Delivery Optimization'] = \"$env:windir\\ServiceProfiles\\NetworkService\\AppData\\Local\\Microsoft\\Windows\\DeliveryOptimization\\Cache\"\n        }\n        \n        # 执行清理\n        foreach ($key in $paths.Keys) {\n            $path = $paths[$key]\n            $sizeBefore = 0\n            $sizeAfter = 0\n            \n            try {\n                # 获取清理前的大小\n                if (Test-Path $path) {\n                    $sizeBefore = (Get-ChildItem $path -Recurse -ErrorAction SilentlyContinue | Measure-Object Length -Sum).Sum\n                }\n                \n                # 清理文件\n                Remove-Item -Path $path\\* -Force -Recurse -ErrorAction SilentlyContinue\n                \n                # 获取清理后的大小\n                if (Test-Path $path) {\n                    $sizeAfter = (Get-ChildItem $path -Recurse -ErrorAction SilentlyContinue | Measure-Object Length -Sum).Sum\n                }\n                \n                $freedSpace = [math]::Round(($sizeBefore - $sizeAfter) / 1MB, 2)\n                if ($freedSpace -gt 0) {\n                    $result.Actions += \"Cleaned $key : $freedSpace MB\"\n                    $result.Details[$key] = @{\n                        Path = $path\n                        SpaceFreed = $freedSpace\n                    }\n                }\n            } catch {\n                $result.Actions += \"Failed to clean $key : $($_.Exception.Message)\"\n            }\n        }\n        \n        if ($aggressive) {\n            # 清理DNS缓存\n            ipconfig /flushdns | Out-Null\n            $result.Actions += \"Cleaned DNS cache\"\n            \n            # 清理缩略图缓存\n            Remove-Item \"$env:LocalAppData\\Microsoft\\Windows\\Explorer\\thumbcache_*.db\" -Force -ErrorAction SilentlyContinue\n            $result.Actions += \"Cleaned thumbnail cache\"\n        }\n        \n        # 清理回收站\n        Clear-RecycleBin -Force -ErrorAction SilentlyContinue\n        $result.Actions += \"Cleaned recycle bin\"\n        \n        # 计算总共释放的空间\n        $afterSize = @{}\n        Get-WmiObject Win32_LogicalDisk | Where-Object { $_.DriveType -eq 3 } | ForEach-Object {\n            $afterSize[$_.DeviceID] = $_.FreeSpace\n            $freed = [math]::Round(($afterSize[$_.DeviceID] - $beforeSize[$_.DeviceID]) / 1MB, 2)\n            if ($freed -gt 0) {\n                $result.Details[$_.DeviceID] = @{\n                    SpaceFreed = $freed\n                }\n                $result.SpaceFreed += $freed\n            }\n        }\n        \n        return $result | ConvertTo-Json -Depth 3\n    } catch {\n        return @{\n            Status = \"Failed\"\n            Error = $_.Exception.Message\n        } | ConvertTo-Json\n    }\n}"
    },
    {
        "name": "扫描网络设备",
        "example": "扫描内网设备。示例：\nScanNetwork  # 扫描默认网段\nScanNetwork -StartIP 192.168.0.1 -EndIP 192.168.0.254  # 扫描指定网段",
        "code": "function ScanNetwork { param([string]$StartIP = '192.168.1.1', [string]$EndIP = '192.168.1.254') function ConvertTo-Int { param([string]$ip) $octets = $ip.Split('.'); return ([int64]$octets[0] * 16777216) + ([int64]$octets[1] * 65536) + ([int64]$octets[2] * 256) + [int64]$octets[3] } function ConvertTo-IP { param([int64]$int) $octet1 = [math]::Floor($int / 16777216); $remainder1 = $int % 16777216; $octet2 = [math]::Floor($remainder1 / 65536); $remainder2 = $remainder1 % 65536; $octet3 = [math]::Floor($remainder2 / 256); $octet4 = $remainder2 % 256; return \"$octet1.$octet2.$octet3.$octet4\" } $startInt = ConvertTo-Int $StartIP; $endInt = ConvertTo-Int $EndIP; $results = @(); Write-Output 'Starting network scan...'; for ($i = $startInt; $i -le $endInt; $i++) { $currentIP = ConvertTo-IP $i; $ping = Test-Connection -ComputerName $currentIP -Count 1 -Quiet; if ($ping) { try { $hostEntry = [System.Net.Dns]::GetHostEntry($currentIP); $hostname = $hostEntry.HostName } catch { $hostname = 'Unknown Host' } try { $mac = (Get-NetNeighbor -IPAddress $currentIP -ErrorAction SilentlyContinue).LinkLayerAddress; if (-not $mac) { $mac = 'Unknown MAC' } } catch { $mac = 'Unknown MAC' } $results += [PSCustomObject]@{ IP = $currentIP; Hostname = $hostname; MAC = $mac; Status = 'Online' } } } if ($results.Count -eq 0) { return 'No devices found' } else { return ($results | ConvertTo-Json) } }"
    }
]